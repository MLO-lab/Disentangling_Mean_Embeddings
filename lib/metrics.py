import numpy as np
from functools import partial
import multiprocess as mp
from sklearn import metrics
from lib.notebook import get_tqdm

tqdm = get_tqdm()

####################################################################################################
#                                                                                                  #
#                                  FROM Sebastian G. Gruber                                        #
#                                                                                                  #
####################################################################################################


def ensemble_block_kernel(X, Y, kernel=lambda x, y: metrics.pairwise.rbf_kernel(x, y, gamma=None)):
    """Compute the block kernel between X and Y.

    Parameters
    ----------
    X : ndarray of shape (n_ensemble, n_samples, n_features)

    Y : ndarray of shape (n_ensemble, n_samples, n_features)

    Returns
    -------
    kernel_block__matrix : ndarray of shape (n_ensemble * n_samples, n_ensemble * n_samples)
    """
    assert Y.shape == X.shape
    n_ens, n_samp, n_feat = X.shape
    # reshapes with index orders [11, 21, ..., n1, 12, 22, ...]
    # where n = n_samples
    X_flat = X.reshape(n_ens * n_samp, n_feat)
    Y_flat = Y.reshape(n_ens * n_samp, n_feat)
    kXY = kernel(X_flat, Y_flat)
    return kXY


def get_diag_blocks(kernel_block_matrix, n_ensemble):
    """Select the entries in the n x n kernel matrices K_ii of the (n*m)x(n*m) kernel block matrix K with i=1...m,
    i.e. sum({K_ii}_jt), where n = n_samples and m = n_ensemble

    Parameters
    ----------
    kernel_block_matrix : ndarray of shape (n_ensemble * n_sample, n_ensemble * n_sample)
    """
    n_all = kernel_block_matrix.shape[0]
    n_samples = int(n_all / n_ensemble)

    return np.array([
        # select n x n matrix K_ii
        kernel_block_matrix[i*n_samples:(i+1)*n_samples, i*n_samples:(i+1)*n_samples] for i in range(n_ensemble)
    ])


def avg_off_diag_blocks(kXY, diag_blocks):
    n_samp = diag_blocks[0].shape[0]
    n_ens = len(diag_blocks)
    return (kXY.sum()-diag_blocks.sum())/(n_samp*n_samp*n_ens*(n_ens-1))


def dist_cov(X, Y, kernel=lambda x, y: metrics.pairwise.rbf_kernel(x, y, gamma=None)):
    """
    Distributional covariance generated by kernel between samples X and Y

    Parameters
    ----------
    X : ndarray of shape (n_ensemble, n_samples, n_features)

    Y : ndarray of shape (n_ensemble, n_samples, n_features)
    """
    n_ens, n_samp, _ = X.shape
    kXY = ensemble_block_kernel(X, Y, kernel=kernel)
    diag_blocks = get_diag_blocks(kXY, n_ens)
    return np.mean(diag_blocks) - avg_off_diag_blocks(kXY, diag_blocks)


def dist_var(X, kernel=lambda x, y: metrics.pairwise.rbf_kernel(x, y, gamma=None)):
    """
    Distributional variance generated by kernel and estimated on samples X

    Parameters
    ----------
    X : ndarray of shape (n_ensemble, n_samples, n_features)
    """
    n_ens, n_samp, _ = X.shape
    kXX = ensemble_block_kernel(X, X, kernel=kernel)
    diag_blocks = get_diag_blocks(kXX, n_ens)
    return (diag_blocks.sum()-kXX.diagonal().sum())/(n_ens*n_samp*(n_samp-1)) - avg_off_diag_blocks(kXX, diag_blocks)


def dist_corr(X, Y, kernel=lambda x, y: metrics.pairwise.rbf_kernel(x, y, gamma=None)):
    """
    Distributional correlation generated by kernel between samples X and Y.
    We use a biased (but consistent) estimator of the variance terms to guarantee
    that the output is in [0, 1].
    An unbiased estimator of the correlation does not exist, so using a biased one
    for the variance terms should not matter.

    Parameters
    ----------
    X : ndarray of shape (n_ensemble, n_samples, n_features)

    Y : ndarray of shape (n_ensemble, n_samples, n_features)
    """
    var_X = dist_cov(X, X, kernel=kernel)
    var_Y = dist_cov(Y, Y, kernel=kernel)
    cov_XY = dist_cov(X, Y, kernel=kernel)
    return cov_XY / np.sqrt(var_X * var_Y)


def kernel_error(X, Y, kernel=lambda x, y: metrics.pairwise.rbf_kernel(x, y, gamma=None)):
    """Negative kernel score using kernel (e.g., rbf (gaussian) kernel k(x,y) = exp(-gamma * ||x-y||^2 / 2))

    Arguments:
        X {[n_sample1, dim]} -- [X matrix]
        Y {[n_sample2, dim]} -- [Y matrix]
        kernel -- pairwise kernel from sklearn.metrics

    Keyword Arguments:
        gamma {float} -- [kernel parameter] (default: {1.0})

    Returns:
        [scalar] -- [negative kernel score value]
    """
    XX = kernel(X, X)
    XY = kernel(X, Y)
    # length of X
    n = XY.shape[0]
    return (XX.sum() - XX.diagonal().sum())/(n*(n-1)) - 2 * XY.mean()


def kernel_noise(Y, kernel=lambda x, y: metrics.pairwise.rbf_kernel(x, y, gamma=None)):
    YY = kernel(Y, Y)
    # length of Y
    n = YY.shape[0]
    return (YY.diagonal().sum() - YY.sum())/(n*(n-1))


def sMMD(X, Y, kernel=lambda x, y: metrics.pairwise.rbf_kernel(x, y, gamma=None)):
    """squared MMD using kernel (e.g., rbf (gaussian) kernel k(x,y) = exp(-gamma * ||x-y||^2 / 2))
    unbiased estimator
    Arguments:
        X {[n_sample1, dim]} -- [X matrix]
        Y {[n_sample2, dim]} -- [Y matrix]
        kernel -- pairwise kernel from sklearn.metrics

    Keyword Arguments:
        gamma {float} -- [kernel parameter] (default: {1.0})

    Returns:
        [scalar] -- [MMD value]
    """
    return kernel_error(X, Y, kernel) - kernel_noise(Y, kernel)


def cos_(X, Y, kernel=lambda x, y: metrics.pairwise.rbf_kernel(x, y, gamma=None)):
    XX = kernel(X, X)
    XY = kernel(X, Y)
    YY = kernel(Y, Y)
    # length of X & Y
    n_X, n_Y = XY.shape
    return XY.mean()/np.sqrt(XX.mean()*YY.mean())


def cos_debias(X, Y, kernel=lambda x, y: metrics.pairwise.rbf_kernel(x, y, gamma=None)):
    XX = kernel(X, X)
    XY = kernel(X, Y)
    YY = kernel(Y, Y)
    # length of X & Y
    n_X, n_Y = XY.shape
    sq_norm_X = (XX.sum() - XX.diagonal().sum())/(n_X*(n_X-1))
    sq_norm_Y = (YY.sum() - YY.diagonal().sum())/(n_Y*(n_Y-1))
    return XY.mean()/np.sqrt(sq_norm_X*sq_norm_Y)


# not used
def Var_inner_term(kernel_block_matrix, n_ensemble):
    """Average the non-diagonal entries in the n x n kernel matrices K_ii of the (n*m)x(n*m) kernel block matrix K with i=1...m,
    i.e. avg({K_ii}_jt) with j =/= t, where n = n_samples and m = n_ensemble

    Parameters
    ----------
    kernel_block_matrix : ndarray of shape (n_ensemble * n_sample, n_ensemble * n_sample)
    """
    n_all = kernel_block_matrix.shape[0]
    n_samples = int(n_all / n_ensemble)

    sum_all = np.sum([
        # select n x n matrix K_ii
        kernel_block_matrix[i*n_samples:(i+1)*n_samples, i*n_samples:(i+1)*n_samples] for i in range(n_ensemble)
    ])
    sum_diag = np.sum(kernel_block_matrix.diagonal())
    return (sum_all - sum_diag) / (n_samples*(n_samples-1)*n_ensemble)


# not used
def Cov_inner_term(kernel_block_matrix, n_ensemble):
    """Average the entries in the n x n kernel matrices K_ii of the (n*m)x(n*m) kernel block matrix K with i=1...m,
    i.e. avg({K_ii}_jt), where n = n_samples and m = n_ensemble

    Parameters
    ----------
    kernel_block_matrix : ndarray of shape (n_ensemble * n_sample, n_ensemble * n_sample)
    """
    n_all = kernel_block_matrix.shape[0]
    n_samples = int(n_all / n_ensemble)
    return np.mean([
        # select n x n matrix K_ii
        kernel_block_matrix[i*n_samples:(i+1)*n_samples, i*n_samples:(i+1)*n_samples] for i in range(n_ensemble)
    ])


# not used
def Cov_outer_term(kernel_block_matrix, n_ensemble):
    """
    Average the entries in the m x m kernel matrices K_ij (i =/= j) of the (n*m)x(n*m) kernel block matrix K with i,j=1...n,
    i.e. avg({K_ij}_st) with i =/= j, where m = n_samples and n = n_ensemble

    Parameters
    ----------
    kernel_block_matrix : ndarray of shape (n_ensemble * n_sample, n_ensemble * n_sample)
    """
    n_all = kernel_block_matrix.shape[0]
    n_samples = int(n_all / n_ensemble)

    return np.mean([
        kernel_block_matrix[i*n_samples:(i+1)*n_samples, j*n_samples:(j+1)*n_samples]
        for i in range(n_ensemble)
        for j in range(n_ensemble)
        if i != j
    ])


# not used; is ~20% slower than the other implementation
def dist_var_(X, kernel=lambda x, y: metrics.pairwise.rbf_kernel(x, y, gamma=None)):
    """
    Distributional variance generated by kernel and estimated on samples X

    Parameters
    ----------
    X : ndarray of shape (n_ensemble, n_samples, n_features)
    """
    n_ens, _, _ = X.shape
    kXX = ensemble_block_kernel(X, X, kernel=kernel)
    return Var_inner_term(kXX, n_ensemble=n_ens) - Cov_outer_term(kXX, n_ensemble=n_ens)


# not used; is ~20% slower than the other implementation
def dist_cov_(X, Y, kernel=lambda x, y: metrics.pairwise.rbf_kernel(x, y, gamma=None)):
    """
    Distributional covariance generated by kernel between samples X and Y

    Parameters
    ----------
    X : ndarray of shape (n_ensemble, n_samples, n_features)

    Y : ndarray of shape (n_ensemble, n_samples, n_features)
    """
    n_ens, _, _ = X.shape
    kXY = ensemble_block_kernel(X, Y, kernel=kernel)
    return Cov_inner_term(kXY, n_ensemble=n_ens) - Cov_outer_term(kXY, n_ensemble=n_ens)


def cov_phi(X, Y, kernel=lambda x, y: metrics.pairwise.rbf_kernel(x, y, gamma=None)):
    """Compute the covariance based on feature map phi of a kernel `kernel`
    between samples X and Y.

    Parameters
    ----------
    X : ndarray of shape (n_samples, n_features)

    Y : ndarray of shape (n_samples, n_features)

    Returns
    -------
    covariance : float
    """
    assert Y.shape == X.shape
    n_samples = X.shape[0]
    kXY = kernel(X, Y)
    avg_off_diag = (kXY.sum() - np.diag(kXY).sum()) / (n_samples**2 - n_samples)
    return np.diag(kXY).mean() - avg_off_diag


def var_phi(X, kernel=lambda x, y: metrics.pairwise.rbf_kernel(x, y, gamma=None)):
    """Compute the variance based on feature map phi of a kernel `kernel`
    of samples X.

    Parameters
    ----------
    X : ndarray of shape (n_samples, n_features)

    Returns
    -------
    variance : float
    """
    return cov_phi(X, X, kernel=kernel)


def corr_phi(X, Y, kernel=lambda x, y: metrics.pairwise.rbf_kernel(x, y, gamma=None)):
    """Compute the correlation based on feature map phi of a kernel `kernel`
    between samples X and Y.

    Parameters
    ----------
    X : ndarray of shape (n_samples, n_features)

    Y : ndarray of shape (n_samples, n_features)

    Returns
    -------
    correlation : float
    """
    covXY = cov_phi(X, Y, kernel=kernel)
    varX = var_phi(X, kernel=kernel)
    varY = var_phi(Y, kernel=kernel)
    return covXY / np.sqrt(varX*varY)

def cos(preds_loader, target_loader, kernel=lambda x, y: metrics.pairwise.rbf_kernel(x, y, gamma=None)):
    """
    """
    return np.mean([
        cos_(xs_per_model, mini_batch_targets, kernel=kernel)
        for xs_per_model in preds_loader
        for mini_batch_targets in target_loader
    ])

def multiprocessed_cos(tests_for_each_epoch, dataloader, kernel=lambda x, y: metrics.pairwise.rbf_kernel(x, y, gamma=None), cpus=8):
    """
    """
    with mp.Pool(cpus) as pool:
        partial_worker_function = partial(cos, target_loader=dataloader, kernel=kernel)
        return np.array(pool.map(partial_worker_function, tests_for_each_epoch))
####################################################################################################
#                                                                                                  #
#                           OPTIMIZATIONS FROM Pascal Tobias Ziegler                               #
#                                                                                                  #
####################################################################################################


def gmmd(test_epoch, dataloader, kernel=lambda x, y: metrics.pairwise.rbf_kernel(x, y, gamma=None)):
    """
    Computes the average generalized maximum mean discrepancy (MMD) over models and mini-batches.

    Args:
        test_epoch (iterable): An iterable where each element represents a set of samples from a model.
                               Each set of samples is compared against all mini-batches from the dataloader.
        dataloader (iterable): An iterable that yields mini-batches of target samples.
        kernel (function): A function that computes the kernel between two sets of samples.
                           The default kernel is the Radial Basis Function (RBF) kernel with an unspecified gamma parameter.

    Returns:
        float: The average MMD score over all models in test_epoch and all mini-batches in dataloader.
    """
    return np.mean([
        sMMD(xs_per_model, mini_batch_targets, kernel=kernel)
        for xs_per_model in test_epoch
        for mini_batch_targets in dataloader
    ])


def gmmd_pixel_wise(yi, x, y, image_size, kernel=lambda x, y: metrics.pairwise.rbf_kernel(x, y, gamma=None)):
    """
    Computes the Generalized Maximum Mean Discrepancy (MMD) for each pixel column in the image.

    Args:
        yi (int): The index of the row (y-coordinate) for which MMD is computed.
        x (numpy.ndarray): A 5D array of samples, typically shaped as (batch_size, height, width, channels, models).
                           Each element represents a set of samples from different models.
        y (numpy.ndarray): A 5D array of target samples with the same shape as `x`.
        image_size (int): The size of the image (assumed to be a square image with dimensions image_size x image_size).
        kernel (function): A function that computes the kernel between two sets of samples.
                           The default kernel is the Radial Basis Function (RBF) kernel with an unspecified gamma parameter.

    Returns:
        list: A list of MMD scores for each pixel column in the specified row `yi`.
    """
    return [
        gmmd(x[:, :, :, yi, xi], y[:, :, :, yi, xi], kernel=kernel) 
        for xi in range(image_size)
    ] 


def multiprocessed_gmmd_pixel_wise(x, y, image_size, cpus=8, kernel=lambda x, y: metrics.pairwise.rbf_kernel(x, y, gamma=None)):
    """
    Computes the Generalized Maximum Mean Discrepancy (MMD) for each pixel column in the image using multiprocessing.

    Args:
        x (numpy.ndarray): A 5D array of samples, typically shaped as (batch_size, height, width, channels, models).
                           Each element represents a set of samples from different models.
        y (numpy.ndarray): A 5D array of target samples with the same shape as `x`.
        image_size (int): The size of the image (assumed to be a square image with dimensions image_size x image_size).
        cpus (int): The number of CPU cores to use for multiprocessing. Default is 8.
        kernel (function): A function that computes the kernel between two sets of samples.
                           The default kernel is the Radial Basis Function (RBF) kernel with an unspecified gamma parameter.

    Returns:
        numpy.ndarray: A 2D array of MMD scores for each pixel column in the image, with shape (image_size, image_size).
    """
    pool = mp.Pool(cpus)
    partial_worker_function = partial(gmmd_pixel_wise, x=x, y=y, image_size=image_size, kernel=kernel)
    return np.array(list(tqdm(pool.imap(partial_worker_function, range(image_size)), total=image_size)))


def multiprocessed_gmmd(tests_for_each_epoch, dataloader, kernel=lambda x, y: metrics.pairwise.rbf_kernel(x, y, gamma=None), cpus=8):
    """
    Computes the Generalized Maximum Mean Discrepancy (MMD) for each set of test samples in parallel using multiprocessing.

    Args:
        tests_for_each_epoch (iterable): An iterable where each element represents a set of samples from different models 
                                         to be tested against the target samples.
        dataloader (iterable): An iterable that yields mini-batches of target samples.
        kernel (function): A function that computes the kernel between two sets of samples.
                           The default kernel is the Radial Basis Function (RBF) kernel with an unspecified gamma parameter.
        cpus (int): The number of CPU cores to use for multiprocessing. Default is 8.

    Returns:
        numpy.ndarray: An array of MMD scores for each set of test samples.
    """
    with mp.Pool(cpus) as pool:
        partial_worker_function = partial(gmmd, dataloader=dataloader, kernel=kernel)
        return np.array(list(tqdm(pool.map(partial_worker_function, tests_for_each_epoch), total=len(tests_for_each_epoch))))


def pixel_wise_correlation(index, image_size, tests, epoch, kernel=lambda x, y: metrics.pairwise.rbf_kernel(x, y, gamma=None)):
    """
    Computes the distance correlation between a specific pixel and all other pixels in an image for a given epoch.

    Args:
        index (int): The linear flatted index of the pixel for which the correlation is to be computed. It need to be set by index = i * image_size + j.
        image_size (int): The size of the image (assumed to be a square image with dimensions image_size x image_size).
        tests (list): A list of numpy arrays where each element corresponds to test samples from different epochs.
                      Each array should be 5D with shape (batch_size, height, width, channels, models).
        epoch (int): The specific epoch for which the correlation is being calculated.
        kernel (function): A function that computes the kernel between two sets of samples.
                           The default kernel is the Radial Basis Function (RBF) kernel with an unspecified gamma parameter.

    Returns:
        list: A 2D list where each element represents the distance correlation between the specified pixel and another pixel in the image.
    """
    i, j = index // image_size, index % image_size
    return [
        [
        dist_corr(tests[epoch][:, :, :, i, j], tests[epoch][:, :, :, px2, py2], kernel=kernel)
            for py2 in range(image_size)
        ]
        for px2 in range(image_size)
    ]


def multiprocessed_pixel_wise_correlation(image_size, tests, epoch, cpus=8, kernel=lambda x, y: metrics.pairwise.rbf_kernel(x, y, gamma=None)):
    """
    Computes the pixel-wise distance correlation between all pixels in an image for a given epoch using multiprocessing.

    Args:
        image_size (int): The size of the image (assumed to be a square image with dimensions image_size x image_size).
        tests (iterable): A iterable of numpy arrays where each element corresponds to test samples from different epochs.
                      Each array should be 5D with shape (batch_size, height, width, channels, models).
        epoch (int): The specific epoch for which the correlation is being calculated.
        cpus (int): The number of CPU cores to use for multiprocessing. Default is 8.
        kernel (function): A function that computes the kernel between two sets of samples.
                           The default kernel is the Radial Basis Function (RBF) kernel with an unspecified gamma parameter.

    Returns:
        numpy.ndarray: A 4D array of pixel-wise correlations with shape (image_size, image_size, image_size, image_size).
    """
    with mp.Pool(cpus) as pool:
        partial_worker_function = partial(pixel_wise_correlation, image_size=image_size, tests=tests, epoch=epoch, kernel=kernel)
        corr = np.array(list(tqdm(pool.imap(partial_worker_function, range(image_size**2)), total=image_size**2)))
        return corr.reshape(image_size, image_size, image_size, image_size)
    

def pixel_wise_correlation_phi(index, image_size, samples, kernel=lambda x, y: metrics.pairwise.rbf_kernel(x, y, gamma=None)):
    """
    Computes the phi correlation between a specific pixel and all other pixels in an image.

    Args:
        index (int): The linear index of the pixel for which the correlation is to be computed.
        image_size (int): The size of the image (assumed to be a square image with dimensions image_size x image_size).
        samples (numpy.ndarray): A 4D numpy array of samples with shape (batch_size, height, width, channels).
        kernel (function): A function that computes the kernel between two sets of samples.
                           The default kernel is the Radial Basis Function (RBF) kernel with an unspecified gamma parameter.

    Returns:
        list: A 2D list where each element represents the phi correlation between the specified pixel and another pixel in the image.
    """
    i, j = index // image_size, index % image_size
    return [
        [
        corr_phi(samples[:, :, i, j], samples[:, :, px2, py2], kernel=kernel)
            for py2 in range(image_size)
        ]
        for px2 in range(image_size)
    ]


def multiprocessed_pixel_wise_correlation_phi(image_size, samples, cpus=8, kernel=lambda x, y: metrics.pairwise.rbf_kernel(x, y, gamma=None)):
    """
    Computes the pixel-wise phi correlation between all pixels in an image using multiprocessing.

    Args:
        image_size (int): The size of the image (assumed to be a square image with dimensions image_size x image_size).
        samples (iterable): An iterable of 4D numpy arrays, where each array has shape (batch_size, height, width, channels).
        cpus (int): The number of CPU cores to use for multiprocessing. Default is 8.
        kernel (function): A function that computes the kernel between two sets of samples.
                           The default kernel is the Radial Basis Function (RBF) kernel with an unspecified gamma parameter.

    Returns:
        numpy.ndarray: A 4D array of pixel-wise phi correlations with shape (image_size, image_size, image_size, image_size).
    """
    with mp.Pool(cpus) as pool:
        partial_worker_function = partial(pixel_wise_correlation_phi, image_size=image_size, samples=samples, kernel=kernel)
        corr = np.array(list(tqdm(pool.imap(partial_worker_function, range(image_size**2)), total=image_size**2)))
        return corr.reshape(image_size, image_size, image_size, image_size)


def main():
    pass


if __name__ == "__main__":
    main()